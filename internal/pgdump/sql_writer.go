package pgdump

import (
	"fmt"
	"io"
	"strings"
	"time"

	"github.com/NhaLeTruc/datagen-cli/internal/schema"
)

// SQLWriter writes PostgreSQL dump in SQL format
type SQLWriter struct {
	w io.Writer
}

// NewSQLWriter creates a new SQL format writer
func NewSQLWriter(w io.Writer) *SQLWriter {
	return &SQLWriter{w: w}
}

// WriteSchema writes the complete schema as SQL
func (sw *SQLWriter) WriteSchema(s *schema.Schema) error {
	// Write header comment
	fmt.Fprintf(sw.w, "--\n")
	fmt.Fprintf(sw.w, "-- PostgreSQL database dump\n")
	fmt.Fprintf(sw.w, "-- Generated by datagen\n")
	fmt.Fprintf(sw.w, "--\n\n")

	// Write database creation
	fmt.Fprintf(sw.w, "CREATE DATABASE %s WITH ENCODING = '%s';\n\n",
		s.Database.Name, s.Database.Encoding)

	fmt.Fprintf(sw.w, "\\connect %s\n\n", s.Database.Name)

	// Write CREATE TABLE statements
	for tableName, table := range s.Tables {
		if err := sw.WriteCreateTable(tableName, table); err != nil {
			return err
		}
		fmt.Fprintf(sw.w, "\n")
	}

	return nil
}

// WriteCreateTable writes a CREATE TABLE statement
func (sw *SQLWriter) WriteCreateTable(tableName string, table *schema.Table) error {
	fmt.Fprintf(sw.w, "CREATE TABLE %s (\n", tableName)

	// Write columns
	for i, col := range table.Columns {
		fmt.Fprintf(sw.w, "    %s %s", col.Name, col.Type)

		if !col.Nullable {
			fmt.Fprintf(sw.w, " NOT NULL")
		}

		if col.DefaultValue != "" {
			fmt.Fprintf(sw.w, " DEFAULT %s", col.DefaultValue)
		}

		if i < len(table.Columns)-1 || len(table.PrimaryKey) > 0 {
			fmt.Fprintf(sw.w, ",")
		}
		fmt.Fprintf(sw.w, "\n")
	}

	// Write primary key
	if len(table.PrimaryKey) > 0 {
		fmt.Fprintf(sw.w, "    PRIMARY KEY (%s)\n", strings.Join(table.PrimaryKey, ", "))
	}

	fmt.Fprintf(sw.w, ");\n")

	// Write indexes
	for _, idx := range table.Indexes {
		fmt.Fprintf(sw.w, "CREATE INDEX %s ON %s (%s);\n",
			idx.Name, tableName, strings.Join(idx.Columns, ", "))
	}

	// Write unique constraints
	for _, uc := range table.UniqueConstraints {
		fmt.Fprintf(sw.w, "ALTER TABLE %s ADD CONSTRAINT %s UNIQUE (%s);\n",
			tableName, uc.Name, strings.Join(uc.Columns, ", "))
	}

	return nil
}

// WriteInsert writes an INSERT statement for a single row
func (sw *SQLWriter) WriteInsert(tableName string, columns []string, row map[string]interface{}) error {
	fmt.Fprintf(sw.w, "INSERT INTO %s (%s) VALUES (",
		tableName, strings.Join(columns, ", "))

	for i, col := range columns {
		val := row[col]
		fmt.Fprintf(sw.w, "%s", sw.formatValue(val))

		if i < len(columns)-1 {
			fmt.Fprintf(sw.w, ", ")
		}
	}

	fmt.Fprintf(sw.w, ");\n")
	return nil
}

// formatValue formats a value for SQL
func (sw *SQLWriter) formatValue(val interface{}) string {
	if val == nil {
		return "NULL"
	}

	switch v := val.(type) {
	case string:
		// Escape single quotes
		escaped := strings.ReplaceAll(v, "'", "''")
		return fmt.Sprintf("'%s'", escaped)
	case int, int32, int64:
		return fmt.Sprintf("%d", v)
	case float32, float64:
		return fmt.Sprintf("%f", v)
	case bool:
		if v {
			return "TRUE"
		}
		return "FALSE"
	case time.Time:
		return fmt.Sprintf("'%s'", v.Format("2006-01-02 15:04:05"))
	default:
		return fmt.Sprintf("'%v'", v)
	}
}