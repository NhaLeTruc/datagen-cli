package pgdump

import (
	"fmt"
	"io"
	"strings"

	"github.com/NhaLeTruc/datagen-cli/internal/schema"
)

// SQLWriter writes PostgreSQL dump in SQL format
type SQLWriter struct {
	w io.Writer
}

// NewSQLWriter creates a new SQL format writer
func NewSQLWriter(w io.Writer) *SQLWriter {
	return &SQLWriter{w: w}
}

// WriteSchema writes the complete schema as SQL
func (sw *SQLWriter) WriteSchema(s *schema.Schema) error {
	// Write header comment
	fmt.Fprintf(sw.w, "--\n")
	fmt.Fprintf(sw.w, "-- PostgreSQL database dump\n")
	fmt.Fprintf(sw.w, "-- Generated by datagen\n")
	fmt.Fprintf(sw.w, "--\n\n")

	// Write database creation
	fmt.Fprintf(sw.w, "CREATE DATABASE %s WITH ENCODING = '%s';\n\n",
		s.Database.Name, s.Database.Encoding)

	fmt.Fprintf(sw.w, "\\connect %s\n\n", s.Database.Name)

	// Write CREATE TABLE statements
	for tableName, table := range s.Tables {
		if err := sw.WriteCreateTable(tableName, table); err != nil {
			return err
		}
		fmt.Fprintf(sw.w, "\n")
	}

	return nil
}

// WriteCreateTable writes a CREATE TABLE statement
func (sw *SQLWriter) WriteCreateTable(tableName string, table *schema.Table) error {
	fmt.Fprintf(sw.w, "CREATE TABLE %s (\n", tableName)

	// Write columns
	for i, col := range table.Columns {
		fmt.Fprintf(sw.w, "    %s %s", col.Name, col.Type)

		if !col.Nullable {
			fmt.Fprintf(sw.w, " NOT NULL")
		}

		if col.DefaultValue != "" {
			fmt.Fprintf(sw.w, " DEFAULT %s", col.DefaultValue)
		}

		if i < len(table.Columns)-1 || len(table.PrimaryKey) > 0 {
			fmt.Fprintf(sw.w, ",")
		}
		fmt.Fprintf(sw.w, "\n")
	}

	// Write primary key
	if len(table.PrimaryKey) > 0 {
		fmt.Fprintf(sw.w, "    PRIMARY KEY (%s)\n", strings.Join(table.PrimaryKey, ", "))
	}

	fmt.Fprintf(sw.w, ");\n")

	// Write indexes
	for _, idx := range table.Indexes {
		fmt.Fprintf(sw.w, "CREATE INDEX %s ON %s (%s);\n",
			idx.Name, tableName, strings.Join(idx.Columns, ", "))
	}

	// Write unique constraints
	for _, uc := range table.UniqueConstraints {
		fmt.Fprintf(sw.w, "ALTER TABLE %s ADD CONSTRAINT %s UNIQUE (%s);\n",
			tableName, uc.Name, strings.Join(uc.Columns, ", "))
	}

	return nil
}

// WriteInsert writes an INSERT statement for a single row
func (sw *SQLWriter) WriteInsert(tableName string, columns []string, row map[string]interface{}) error {
	fmt.Fprintf(sw.w, "INSERT INTO %s (%s) VALUES (",
		tableName, strings.Join(columns, ", "))

	for i, col := range columns {
		val := row[col]
		fmt.Fprintf(sw.w, "%s", sw.formatValue(val))

		if i < len(columns)-1 {
			fmt.Fprintf(sw.w, ", ")
		}
	}

	fmt.Fprintf(sw.w, ");\n")
	return nil
}

// formatValue formats a value for SQL using the escape module
func (sw *SQLWriter) formatValue(val interface{}) string {
	return FormatValue(val)
}

// WriteBatchInsert writes batched INSERT statements for multiple rows
func (sw *SQLWriter) WriteBatchInsert(tableName string, columns []string, rows []map[string]interface{}, batchSize int) error {
	if len(rows) == 0 {
		return nil
	}

	if batchSize <= 0 {
		batchSize = 100 // Default batch size
	}

	// Process rows in batches
	for i := 0; i < len(rows); i += batchSize {
		end := i + batchSize
		if end > len(rows) {
			end = len(rows)
		}

		batch := rows[i:end]

		// Write INSERT statement header
		fmt.Fprintf(sw.w, "INSERT INTO %s (%s) VALUES\n",
			EscapeIdentifier(tableName), FormatIdentifierList(columns))

		// Write value rows
		for j, row := range batch {
			fmt.Fprintf(sw.w, "    (")

			values := make([]interface{}, len(columns))
			for k, col := range columns {
				values[k] = row[col]
			}

			fmt.Fprintf(sw.w, "%s)", FormatValueList(values))

			if j < len(batch)-1 {
				fmt.Fprintf(sw.w, ",\n")
			} else {
				fmt.Fprintf(sw.w, ";\n")
			}
		}
	}

	return nil
}