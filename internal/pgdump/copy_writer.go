package pgdump

import (
	"fmt"
	"io"
	"strings"

	"github.com/NhaLeTruc/datagen-cli/internal/schema"
)

// COPYWriter writes PostgreSQL dump in COPY format
type COPYWriter struct {
	w io.Writer
}

// NewCOPYWriter creates a new COPY format writer
func NewCOPYWriter(w io.Writer) *COPYWriter {
	return &COPYWriter{w: w}
}

// WriteSchema writes the complete schema as COPY format
func (cw *COPYWriter) WriteSchema(s *schema.Schema) error {
	// Write header comment
	fmt.Fprintf(cw.w, "--\n")
	fmt.Fprintf(cw.w, "-- PostgreSQL database dump (COPY format)\n")
	fmt.Fprintf(cw.w, "-- Generated by datagen\n")
	fmt.Fprintf(cw.w, "--\n\n")

	// Write database creation
	fmt.Fprintf(cw.w, "CREATE DATABASE %s WITH ENCODING = '%s';\n\n",
		EscapeIdentifier(s.Database.Name), s.Database.Encoding)

	fmt.Fprintf(cw.w, "\\connect %s\n\n", s.Database.Name)

	// Write CREATE TABLE statements
	for tableName, table := range s.Tables {
		if err := cw.WriteCreateTable(tableName, table); err != nil {
			return err
		}
		fmt.Fprintf(cw.w, "\n")
	}

	return nil
}

// WriteCreateTable writes a CREATE TABLE statement
func (cw *COPYWriter) WriteCreateTable(tableName string, table *schema.Table) error {
	fmt.Fprintf(cw.w, "CREATE TABLE %s (\n", EscapeIdentifier(tableName))

	// Write columns
	for i, col := range table.Columns {
		fmt.Fprintf(cw.w, "    %s %s", EscapeIdentifier(col.Name), col.Type)

		if !col.Nullable {
			fmt.Fprintf(cw.w, " NOT NULL")
		}

		if col.DefaultValue != "" {
			fmt.Fprintf(cw.w, " DEFAULT %s", col.DefaultValue)
		}

		if i < len(table.Columns)-1 || len(table.PrimaryKey) > 0 {
			fmt.Fprintf(cw.w, ",")
		}
		fmt.Fprintf(cw.w, "\n")
	}

	// Write primary key
	if len(table.PrimaryKey) > 0 {
		fmt.Fprintf(cw.w, "    PRIMARY KEY (%s)\n", FormatIdentifierList(table.PrimaryKey))
	}

	fmt.Fprintf(cw.w, ");\n")

	// Write indexes
	for _, idx := range table.Indexes {
		indexName := idx.Name
		if indexName == "" {
			indexName = fmt.Sprintf("%s_%s_idx", tableName, strings.Join(idx.Columns, "_"))
		}
		fmt.Fprintf(cw.w, "CREATE INDEX %s ON %s (%s);\n",
			EscapeIdentifier(indexName), EscapeIdentifier(tableName), FormatIdentifierList(idx.Columns))
	}

	// Write unique constraints
	for _, uc := range table.UniqueConstraints {
		constraintName := uc.Name
		if constraintName == "" {
			constraintName = fmt.Sprintf("%s_%s_key", tableName, strings.Join(uc.Columns, "_"))
		}
		fmt.Fprintf(cw.w, "ALTER TABLE %s ADD CONSTRAINT %s UNIQUE (%s);\n",
			EscapeIdentifier(tableName), EscapeIdentifier(constraintName), FormatIdentifierList(uc.Columns))
	}

	return nil
}

// WriteCopyHeader writes the COPY FROM stdin header
func (cw *COPYWriter) WriteCopyHeader(tableName string, columns []string) error {
	fmt.Fprintf(cw.w, "COPY %s (%s) FROM stdin;\n",
		EscapeIdentifier(tableName), FormatIdentifierList(columns))
	return nil
}

// WriteCopyRow writes a single data row in COPY format (tab-separated values)
func (cw *COPYWriter) WriteCopyRow(columns []string, row map[string]interface{}) error {
	fmt.Fprintf(cw.w, "%s\n", FormatCopyRow(columns, row))
	return nil
}

// WriteCopyFooter writes the COPY FROM stdin footer
func (cw *COPYWriter) WriteCopyFooter() error {
	fmt.Fprintf(cw.w, "\\.\n")
	return nil
}
